FUNCTION_BLOCK "FB200_EM_Cooling"
{
    S7_Optimized_Access := 'TRUE'
}
AUTHOR : 'Jules'
VERSION : '2.0' // Reworked for single heat exchanger unit design.

VAR_INPUT
    // Enables the block's execution. If FALSE, all outputs are forced to a safe state.
    Enable : Bool;
    
    // Analog cooling demand (0.0 - 100.0%) from the main temperature controller.
    Cooling_Demand_In : Real;
END_VAR

VAR
    // The data interface for the Heat Exchanger Cooling Valve Module.
    UDT : "UDT200_EM_Cooling";

    // Internal timer for the valve feedback failure delay.
    feedbackFaultTimer : TON_TIME;
END_VAR

BEGIN
    //================================================================================
    // REGION 1: Main Execution Logic
    // The block's logic only runs if it is enabled by the main program.
    //================================================================================
    
    IF #Enable THEN
    
        //----------------------------------------------------------------------------
        // SUB-REGION 1.1: Safety Monitoring (Highest Priority)
        // A freeze stat trip on the shared heat exchanger coil must immediately
        // override all other logic and force the valve closed.
        //----------------------------------------------------------------------------
        
        IF #UDT.CHW_Freeze_Stat_DI THEN
            // A freeze condition is detected on the shared coil.
            #UDT.CHW_Freeze_Alm := TRUE;      // Set the freeze alarm bit.
            #UDT.CHW_Valve_Position_Cmd_AO := 0.0;     // CRITICAL: Force the valve command to 0%.
            #UDT.Valve_Position_Failure_Alm := FALSE;  // Reset failure alarm during freeze condition.
            
        ELSE
            //------------------------------------------------------------------------
            // SUB-REGION 1.2: Normal Operation
            // If there are no active safety trips, the block operates normally.
            //------------------------------------------------------------------------
            
            #UDT.CHW_Freeze_Alm := FALSE;     // Ensure the alarm is clear.
            
            // Pass the incoming analog demand directly to the analog output command.
            #UDT.CHW_Valve_Position_Cmd_AO := #Cooling_Demand_In;

            //------------------------------------------------------------------------
            // SUB-REGION 1.3: Feedback Failure Monitoring
            // Compares the valve command with the feedback to detect a fault.
            //------------------------------------------------------------------------

            // The timer runs if the absolute difference between command and feedback
            // is greater than the configured tolerance.
            #feedbackFaultTimer(
                IN := ABS(REAL_TO_LREAL(#UDT.CHW_Valve_Position_Cmd_AO) - REAL_TO_LREAL(#UDT.CHW_Valve_Position_Fdbk_AI)) > #UDT.Fault_Tolerance_Perc,
                PT := #UDT.Fault_Delay_Sec,
                Q => NOP,
                ET => NOP
            );

            // If the timer completes, it means the mismatch has persisted for too long.
            IF #feedbackFaultTimer.Q THEN
                #UDT.Valve_Position_Failure_Alm := TRUE;
            END_IF;

        END_IF;
        
    ELSE // This ELSE corresponds to "IF #Enable"
        //============================================================================
        // REGION 2: Disabled State Logic
        // If the entire block is disabled, force all outputs to a safe, off state
        // and reset all alarms.
        //============================================================================
        
        #UDT.CHW_Valve_Position_Cmd_AO := 0.0;
        #UDT.CHW_Freeze_Alm := FALSE;
        #UDT.Valve_Position_Failure_Alm := FALSE;
        
    END_IF;

END_FUNCTION_BLOCK